import os
import time
import requests
import datetime as dt
import interactions
from interactions import SlashContext, listen, slash_command, Embed, OptionType, slash_option, \
    ButtonStyle, ActionRow, Button
from interactions.models.discord.channel import ThreadChannel  # ph√°t tri·ªÉn code s·ª≠ d·ª•ng module threadchannel
from interactions.api.events import Startup, VoiceStateUpdate, Component, MessageCreate  # d√πng VoiceUserLeave ƒë·ªÉ l·∫Øng
import google.generativeai as palm
from Queue import NaffQueue
from yt_download import YTAudio
import logging
import datetime
import openai
import json
import video_info

gpt = os.getenv("OPENAI_API_KEY")
bard = os.getenv("PALM_API_KEY")
api_key = os.getenv('YOUTUBE_API_KEY')
palm.configure(api_key=bard)
openai.api_key = gpt

messages = [{"role": "system", "content":
    "You are a intelligent assistant."}]

now = datetime.datetime.now()
formatted_time = now.strftime('%Y-%m-%d_%H-%M')
log_filename = f'log_{formatted_time}.txt'
logger = logging.getLogger('discord_log')
logger.setLevel(logging.DEBUG)
fh = logging.FileHandler(log_filename, encoding='utf-8')
fh.setLevel(logging.DEBUG)
ch = logging.StreamHandler()
ch.setLevel(logging.DEBUG)
formatter = logging.Formatter('[%(asctime)s] [%(levelname)s] %(message)s', datefmt='%H:%M:%S')
fh.setFormatter(formatter)
ch.setFormatter(formatter)
logger.addHandler(fh)
logger.addHandler(ch)

Token = os.getenv("Discord_Token_Bot_A")
# Token = os.getenv("Discord_Token_bot_B")
# bot = interactions.Client()
startup = dt.datetime.utcnow()

Client: interactions.Client = interactions.Client(
    send_command_tracebacks=False,
)
bot = interactions.Client(
    intents=interactions.Intents.DEFAULT | interactions.Intents.MESSAGE_CONTENT)  # specifically message content,


# not just messages


# @interactions.listen()
# async def on_message_create(event: MessageCreate):
#     print(event.message.channel.id)
#     print(event.message.content)


@listen(Startup)
async def _starup():
    logger.debug(f" >> Bot Da Hoat dong! Ten: {bot.user.display_name}")
    await bot.change_presence(status=interactions.Status.IDLE, activity="l·ªánh /help ƒë·ªÉ gi√∫p ƒë·ª°")


@slash_command(name="help", description="Tr·ª£ Gi√∫p")
async def _help(ctx: SlashContext):
    logger.debug(f"[{ctx.guild.name}]::[{ctx.user.display_name}]: > HELP")
    embed = Embed(
        title="**Gi√∫p ƒê·ª°**                       ",
        description="  ",
        color=0x6DAEDB,
    )
    embed.set_author(name=ctx.author.display_name, icon_url=ctx.author.avatar_url)
    embed.add_field(name="**üìñÔ∏è ‚ïè COMMAND**",
                    value='„Ö§  /about -- Tr·∫°ng th√°i bot\n„Ö§ /Play -- Ch∆°i nh·∫°c\n /ask -- H·ªèi bot\n /img -- kh√¥ng d√πng')
    await ctx.send(embed=embed)


end_time = 0.0
start_time = 0.0


@slash_command(name="about", description="Tr·∫°ng Th√°i Bot")
async def _about(ctx: SlashContext):
    logger.debug(f"[{ctx.guild.name}]::[{ctx.user.display_name}]: > ABOUT")
    embed2 = Embed(
        title="BOT STATUS",
        description="„Ö§",
        color=0x00ff00,
    )
    buttn = ActionRow(
        Button(
            style=ButtonStyle.URL,
            label="github.com",
            url="https://github.com/Tinhdev061"
        )
    )

    cacl = dt.datetime.utcnow()
    embed2.add_field(name="üåêPING", value=f"{round(bot.latency * 1000)} ms„Ö§„Ö§„Ö§„Ö§„Ö§", inline=True)
    embed2.add_field(name="üü¢UPTIME", value=f"{cacl - startup}", inline=True)
    embed2.add_field(name="ü§ñAPI Ph·∫£n h·ªìi", value=f'{end_time - start_time} Gi√¢y')
    embed2.add_field(name="Author: ", value="qpneruy (TinhDev061)")
    await ctx.send(embeds=embed2, components=buttn)


@slash_command(name="askbard", description="H·ªèi Palm 1 c√¢u h·ªèi")
@interactions.slash_option(
    name="content",
    description="N·ªôi dung c√¢u h·ªèi",
    opt_type=3,
    required=True,
)
# @slash_option(
#     name="vai",
#     description="T√¥i n√™n tr·∫£ l·ªùi th·∫ø n√†o",
#     opt_type=3,
#     required=False,
# )
async def _askbard(ctx: SlashContext, content: str):
    global mes
    logger.debug(f"[{ctx.guild.name}]::[{ctx.user.display_name}]: > ASKBARD: {content}")
    await ctx.defer()
    if mes is None:
        mes = palm.chat(messages=content)
    else:
        mes = mes.reply(message=content)
    if mes.last is None:
        await _endbard(ctx)
    else:
        await ctx.send(f'**{ctx.user.display_name}**: {content} \n **bard:** {mes.last}')


@slash_command(name="endbard", description="k·∫øt th√∫c ch·ªß ƒë·ªÅ")
async def _endbard(ctx: SlashContext):
    global mes
    logger.debug(f"[{ctx.guild.name}]::[{ctx.user.display_name}]: > ENBARD: ")
    formatted_t = now.strftime('%Y-%m-%d_%H-%M')
    with open(formatted_t + '.json', "w") as f:
        json.dump(mes.messages, f)
    mes = None
    await ctx.send("ƒê√£ k·∫øt th√∫c ch·ªß ƒë·ªÅ")


mes = None


@slash_command(name="askgpt", description="H·ªèi gpt 1 c√¢u h·ªèi")
@interactions.slash_option(
    name="content",
    description="n·ªôi dung c√¢u h·ªèi",
    opt_type=3,
    required=True
)
async def _askgpt(ctx: SlashContext, content: str):
    global end_time, start_time
    logger.debug(f"[{ctx.guild.name}]::[{ctx.user.display_name}]: > ASKGPT: {content}")
    await ctx.defer()
    if len(content) <= 2000:
        message = content
        start_time = time.time()
        if message:
            messages.append(
                {"role": "user", "content": message},
            )
            chat = openai.ChatCompletion.create(
                model="gpt-3.5-turbo", messages=messages
            )
            reply = chat.choices[0].message.content
            if len(reply) > 2000:
                await ctx.send('c√¢u tr·∫£ l·ªùi qu√° d√†i vui l√≤ng h·ªèi c√¢u h√°c :))')
            else:
                end_time = time.time()
                await ctx.send(
                    f'**{ctx.user.display_name}:** {content}\n**qpneruy:** {reply}\n||Response Time: {end_time - start_time} seconds||')

        messages.append({"role": "assistant", "content": reply})
    else:
        await ctx.send("tin nh·∫Øn qu√° 2000 k√Ω t·ª±", ephemeral=True)


@slash_command(name='img', description="T·∫°o ·∫£nh theo m√¥ t·∫£")
@interactions.slash_option("prompt", "m√¥ t·∫£ ·∫£nh", 3, True)
async def _img(ctx: SlashContext, prompt: str):
    if ctx.author == bot.owners:
        await ctx.defer()
        response = openai.Image.create(
            prompt=prompt,
            n=1,
            size="1024X1024"
        )
        image_url = response['data'][0]['url']
        await ctx.send(image_url)


@slash_command(name="menu", description="Menu ch∆°i nh·∫°c")
async def _menu(ctx: SlashContext):
    global hang2, hang1
    await ctx.send(components=[hang1, hang2])


hang1 = ActionRow(
    Button(
        custom_id="pause_button",
        style=ButtonStyle.BLUE,
        label="‚è∏Ô∏è T·∫°m D·ª´ng",
    ),
    Button(
        custom_id="stop_button",
        style=ButtonStyle.RED,
        label="üõë D·ª´ng ",
    ),
    Button(
        custom_id="resume_button",
        style=ButtonStyle.GREEN,
        label="‚ñ∂Ô∏è Ti·∫øp t·ª•c",
    ),
    Button(
        custom_id="loop_button",
        style=ButtonStyle.GREEN,
        label="üîÇ L·∫∑p l·∫°i",
    )
)
hang2 = ActionRow(
    Button(
        custom_id="vol_up",
        style=ButtonStyle.GREEN,
        label="‚ûï TƒÉng √Çm L∆∞·ª£ng",
    ),
    Button(
        custom_id="vol_down",
        style=ButtonStyle.GREEN,
        label="‚ûñ Gi·∫£m √Çm L∆∞·ª£ng",
    ),
    Button(
        custom_id="skip_button",
        style=ButtonStyle.GREY,
        label="‚è≠Ô∏è Ti·∫øp theo",
    )
)

queues = NaffQueue
videoinfo = video_info.VideoInfo()


def get_avt_audio(audio_d):
    search_query = audio_d.entry['title']
    url_video = videoinfo.search_vid(search_query)
    return videoinfo.get_uploader_avt(url_video)


@slash_command(name="play", description="ch∆°i nh·∫°c")
@interactions.slash_option("song", "ƒê∆∞·ªùng d·∫´n nh·∫°c & T√™n b√†i h√°t", 3, True)
async def play(ctx: SlashContext, song: str):
    logger.debug(f"[{ctx.guild.name}]::[{ctx.user.display_name}]: > PLAY ")
    global queues, videoinfo
    global hang2, hang1, api_key
    current_channel = None
    User_inVoice = True
    await ctx.defer()
    ppl_url = "https://www.youtube.com/playlist?list="
    if not ctx.voice_state:
        if ctx.author.voice is not None:
            await ctx.author.voice.channel.connect()
            current_channel = ctx.voice_state.channel.voice_state
            User_inVoice = True
            queues = NaffQueue(current_channel)
            videoinfo = video_info.VideoInfo()
        else:
            await ctx.send('B·∫°n ph·∫£i ·ªü trong 1 k√™nh tho·∫°i', ephemeral=True)
            logger.debug(f'User {ctx.user.display_name} is not in voice channel')
            User_inVoice = False
    if ppl_url in song:
        list_url = await videoinfo.playlist_get(song)
        while videoinfo.peek():
            link = list_url.pop()
            print('alo')
            audio = await YTAudio.from_url(link, stream=True)
            avatar_url = videoinfo.get_uploader_avt(link)
            queues.put(audio, avatar_url)
        await ctx.send("Th√™m danh s√°ch th√†nh c√¥ng", ephemeral=True)
        queues.start()
    elif User_inVoice:
        if ctx.voice_state is not None and ctx.voice_state.channel.voice_state.playing is True:
            audio = await YTAudio.from_url(song, stream=True)
            avatar_url = get_avt_audio(audio)

            queues.put(audio, avatar_url)
            embed = queues.__song_list__[0]
            embed.set_author('‚ûï ƒê√£ Th√™m V√†o h√†ng ƒë·ª£i')
            await ctx.send(embed=embed)
        else:
            queues = NaffQueue(current_channel)
            videoinfo = video_info.VideoInfo()
            if "https://www.youtube.com/watch?v=" in song or "https://youtu.be/" in song:
                audio = await YTAudio.from_url(song, stream=True)
                avatar_url = videoinfo.get_uploader_avt(song)
                queues.put(audio, avatar_url)
            else:
                audio = await YTAudio.from_url(song, stream=True)
                avatar_url = get_avt_audio(audio)
                queues.put(audio, ctx, avatar_url)
            embed = queues.__song_list__[0]
            embed.set_author('üìÄ ƒêang Ch∆°i Nh·∫°c')
            await ctx.send(embeds=embed, components=[hang1, hang2])
            queues.start()


@listen(Component)
async def on_component(event: Component):
    ctx = event.ctx
    match ctx.custom_id:
        case "pause_button":
            await _pause(ctx)
        case "stop_button":
            await _stop(ctx)
        case "resume_button":
            await _resume(ctx)
        case "vol_up":
            await _volup(ctx)
        case "vol_down":
            await _voldown(ctx)
        case "skip_button":
            await _skip(ctx)
        # case "loop_button":
        #     await _loop(ctx)


@slash_command(name="skip", description="B·ªè qua nh·∫°c")
async def _skip(self: SlashContext):
    global queues
    logger.debug(f"[{self.guild.name}]::{self.user.display_name}] >skip \n")
    player = self.bot.get_bot_voice_state(self.guild_id)
    next_item = queues.peek()
    if next_item is not None:
        await player.stop()
        await self.send('ƒê√£ skip', ephemeral=True)
        await self.voice_state.wait_for_stopped()
    else:
        await self.send("H·∫øt nh·∫°c trong h√†ng ƒë·ª£i", ephemeral=True)


@slash_command(name="stop", description="D·ª´ng Nh·∫°c")
async def _stop(ctx):
    logger.debug(f"[{ctx.guild.name}]::[{ctx.user.display_name}]: >stop \n")
    if ctx.voice_state.channel.voice_state.playing is not True:
        await ctx.send("ƒêang kh√¥ng ph√°t nh·∫°c", ephemeral=True)
    else:
        player = ctx.bot.get_bot_voice_state(ctx.guild_id)
        await player.stop()
        await ctx.send('ƒê√£ D·ª´ng', ephemeral=True)


@slash_command(name="resume", description="Ti·∫øp t·ª•c nh·∫°c")
async def _resume(ctx):
    global queues
    logger.debug(f"[{ctx.guild.name}]::[{ctx.user.display_name}]: >resume \n")
    player = ctx.bot.get_bot_voice_state(ctx.guild_id)
    player.resume()
    if ctx.voice_state.channel.voice_state.playing is not True:
        await ctx.send('ƒê√£ ti·∫øp t·ª•c', ephemeral=True)
    else:
        await ctx.send('Kh√¥ng c√≥ nh·∫°c ƒëang d·ª´ng', ephemeral=True)


@slash_command(name="pause", description="t·∫°m d·ª´ng nh·∫°c")
async def _pause(ctx):
    logger.debug(f"[{ctx.guild.name}]::[{ctx.user.display_name}]: >pause \n")
    if ctx.voice_state.channel.voice_state.playing is not True:
        await ctx.send("ƒêang kh√¥ng ph√°t nh·∫°c")
    else:
        player = ctx.bot.get_bot_voice_state(ctx.guild_id)
        player.pause()
        await ctx.send('ƒê√£ t·∫°m d·ª´ng', ephemeral=True)


currvol = 0.5


async def _volup(ctx):
    global currvol
    logger.debug(f"[{ctx.guild.name}]::[{ctx.user.display_name}]: >vol_up \n")
    player = ctx.bot.get_bot_voice_state(ctx.guild_id)
    currvol += 0.1
    player.volume = currvol
    await ctx.send('ƒê√£ TƒÉng √¢m l∆∞·ª£ng', ephemeral=True)


async def _voldown(ctx):
    global currvol
    logger.debug(f"[{ctx.guild.name}]::[{ctx.user.display_name}]: >vol_down \n")
    player = ctx.bot.get_bot_voice_state(ctx.guild_id)
    currvol -= 0.1
    player.volume = currvol
    await ctx.send('ƒê√£ Gi·∫£m √¢m l∆∞·ª£ng', ephemeral=True)


channels = None
channel = None


async def get_remaining_members(channeli):
    members = await channeli.fetch_members()
    num_members = len(members)
    return num_members


@listen(VoiceStateUpdate)
async def _join(vs: VoiceStateUpdate):
    global channels, channel
    if vs.after is not None and vs.after.channel.id == channels:
        channel = await vs.after.guild.create_voice_channel(f"K√™nh {vs.after.member.display_name} ")
        await vs.after.member.move(channel.id)
    if vs.before is not None and (channel is not None and vs.before.channel.id == channel.id):
        await vs.before.guild.delete_channel(channel.id)
    if vs.before is not None:
        voice_channel = vs.before.channel
        members_in_channel = voice_channel.members
        num_members = len(members_in_channel)
        if num_members < 3 and vs.bot.get_bot_voice_state(vs.before.guild) is not None:
            await vs.bot.get_bot_voice_state(vs.before.guild).disconnect()


@slash_command(name="setup", description="ƒê·∫∑t k√™nh voiceS")
@slash_option(name="channel", description="Ch·ªçn k√™nh", opt_type=OptionType.CHANNEL, required=True)
async def _setup(ctx: SlashContext, channeli: interactions.OptionType.CHANNEL):
    global channels
    logger.debug(f"[{ctx.guild.name}]::[{ctx.user.display_name}]: > SETUP  \n")
    channels = channeli.id
    await ctx.send(f"ƒë√£ ƒë·∫∑t k√™nh {channeli.name} th√†nh k√™nh voiceS")


bot.start(Token)
