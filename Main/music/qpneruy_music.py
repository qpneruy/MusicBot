import os
import json
import logging
import aiohttp
import pymysql
import datetime
import interactions
from interactions import SlashContext, listen, slash_command, Embed, OptionType
from interactions.api.events import VoiceUserJoin, VoiceUserLeave
from interactions import ButtonStyle, ActionRow, Button, slash_option
from interactions.api.events import Startup, MessageCreate

"""---------------------------------------------------------------------------------"""

api_key = os.getenv('YOUTUBE_API_KEY')
Token = os.getenv("Discord_Token_Bot_A")

"""-----------------------------"""
# C·∫•u h√¨nh cho module Logging
now = datetime.datetime.now()
formatted_time = now.strftime('%Y-%m-%d_%H-%M')
log_filename = f'Log//log_{formatted_time}.txt'
logger = logging.getLogger('discord_log')
logger.setLevel(logging.DEBUG)
fh = logging.FileHandler(log_filename, encoding='utf-8')
fh.setLevel(logging.DEBUG)
ch = logging.StreamHandler()
ch.setLevel(logging.DEBUG)
formatter = logging.Formatter('[%(asctime)s] [%(levelname)s] %(message)s', datefmt='%H:%M:%S')
fh.setFormatter(formatter)
ch.setFormatter(formatter)
logger.addHandler(fh)
logger.addHandler(ch)
startup = datetime.datetime.utcnow()
"""-----------------------------"""

"""-----------------------------"""
bot = interactions.Client(
    intents=interactions.Intents.DEFAULT | interactions.Intents.MESSAGE_CONTENT, send_command_tracebacks=False)

model_data = {
    "history": {
        "word_list": [],
        "previous_user": "None",
    },
    "current": "None",
}
"""-----------------------------"""


@listen()
async def on_message(event: MessageCreate):
    if event.message.author.id == event.bot.user.id:
        return
    async with aiohttp.ClientSession() as session:
        with pymysql.connect(host=host, user='root', password=password, database=database) as connect_thread:
            with connect_thread.cursor() as cnx:
                query = "SELECT CAST(word_connect_id AS SIGNED) FROM server_data WHERE ten_server = %s"
                cnx.execute(query, (event.message.author.guild.id,))
                data = cnx.fetchone()
                data = data[0] if data else None
                # Ki·ªÖm tra id channel | ki·ªÉm tra c√≥ t·ªìn t·∫°i t·ª´ hay kh√¥ng
                if data != event.message.channel.id:
                    return
        user_word = event.message.content
        user_word = user_word.lower()
        async with session.get(
                f"https://api.dictionaryapi.dev/api/v2/entries/en/{user_word}") as response:
            api_data = await response.json()
        if ("title" in api_data) or (' ' in user_word):
            await event.message.add_reaction('‚ùå')
            await event.message.channel.send(f"T·ª´ `{user_word}` Kh√¥ng T·ªìn t·∫°i trong t·ª´ ƒëi·ªÉn c·ªßa bot")
            return
        """---------------------------------------------------------------------------"""
        # load d·ªØ li·ªáu t·ª´ file data thu·ªôc m·ªói ctx.guild.id
        with open(f"json/word_data_sv_{event.message.author.guild.id}", "r") as datafile:
            data = json.load(datafile)
        previous_word = data["current"]
        """---------------------------------------------------------------------------"""
        # ki·ªÉm tra ng∆∞·ªùi n·ªëi t·ª´ hi·ªán t·∫°i ƒë√£ n·ªëi t·ª´ tr∆∞·ªõc ƒë√≥ hay kh√¥ng
        # if data["history"]["previous_user"] == event.message.author.id:
        #     await event.message.channel.send("B·∫°n ƒë√£ n·ªëi t·ª´ tr∆∞·ªõc ƒë√≥ r·ªìi")
        #     await event.message.add_reaction('‚ùå')
        #     return
        """---------------------------------------------------------------------------"""
        # ki·ªÉm tra xem t·ª´ ƒë√£ ƒë∆∞·ª£c n·ªëi tr∆∞·ªõc ƒë√≥ hay ch∆∞a
        if user_word in data["history"]["word_list"]:
            await event.message.channel.send(f"T·ª´ `{user_word}` ƒê√£ c√≥ ng∆∞·ªùi n·ªëi tr∆∞·ªõc")
            await event.message.add_reaction('‚ùå')
            return
        """---------------------------------------------------------------------------"""
        # ki·ªÉm tra xem k√Ω t·ª± cu·ªëi c·ªßa ch·ªØ n√†y c√≥ b·∫±ng k√Ω t·ª± ƒë·∫ßu c·ªßa ch·ªØ kia kh√¥ng
        # ƒê·ªìng th·ªùi n·∫øu th·ªèa m√£n th√¨ l∆∞u d·ªØ li·ªáu l·∫°i
        if user_word[0] == previous_word[len(previous_word) - 1] or previous_word == "None":
            await event.message.add_reaction('‚úÖ')
            data["current"] = user_word
            data["history"]["word_list"].append(user_word)
            data["history"]["previous_user"] = event.message.author.id
            with open(f"json/word_data_sv_{event.message.author.guild.id}", "w") as datafile:
                json.dump(data, datafile, indent=4)
        else:
            await event.message.channel.send(
                f"T·ª´ `{user_word}` Kh√¥ng b·∫Øt ƒë·∫ßu b·∫±ng k√Ω t·ª± `{previous_word[len(previous_word) - 1]}`")
            await event.message.add_reaction('‚ùå')


@slash_command(name="reset_noi_chu", description="X√≥a d·ªØ li·ªáu")
async def _reset(ctx: SlashContext):
    global model_data
    with open(f"json/word_data_sv_{ctx.guild.id}", "w") as datafile:
        json.dump(model_data, datafile, indent=4)
    await ctx.send(f"‚Ü©Ô∏è ƒê√£ reset n·ªëi ch·ªØ")


@slash_command(name="word_setup", description="ƒê·∫∑t k√™nh n·ªëi ch·ªØ")
@slash_option(name="channel", description="Ch·ªçn k√™nh", opt_type=OptionType.CHANNEL, required=True)
async def _world_setup(ctx: SlashContext, channel: OptionType.CHANNEL):
    global model_data
    with open(f'json/word_data_sv_{ctx.guild.id}', 'w') as f:
        json.dump(model_data, f, indent=4)
    await ctx.send(f'ƒê√£ ƒê·∫∑t k√™nh {channel.name} th√†nh k√™nh n·ªëi ch·ªØ')
    ctx = channel
    await ctx.send('‚úÖ B·∫Øt ƒë·∫ßu ch∆°i')


@slash_command(name="rs", description="rs")
async def rs(ctx: SlashContext):
    bot.reload_extension("play")
    bot.reload_extension("gpt")
    bot.reload_extension("bard")
    await ctx.send('ƒê√£ reset l·∫°i command')


@listen(Startup)
async def _starup():
    logger.debug(f" >> Bot Da Hoat dong! Ten: {bot.user.display_name}")
    await bot.change_presence(status=interactions.Status.IDLE, activity="l·ªánh /help ƒë·ªÉ gi√∫p ƒë·ª°")


@slash_command(name="help", description="Tr·ª£ Gi√∫p")
async def _help(ctx: SlashContext):
    logger.debug(f"[{ctx.guild.name}]::[{ctx.user.display_name}]: > HELP")
    embed = Embed(
        title="**Gi√∫p ƒê·ª°**                       ",
        description="  ",
        color=0x6DAEDB,
    )
    embed.set_author(name=ctx.author.display_name, icon_url=ctx.author.avatar_url)
    embed.add_field(name="**üìñÔ∏è ‚ïè COMMAND**",
                    value='„Ö§  /about -- Tr·∫°ng th√°i bot\n„Ö§ /Play -- Ch∆°i nh·∫°c\n /ask -- H·ªèi bot\n /img -- kh√¥ng d√πng')
    await ctx.send(embed=embed)


end_time = 0.0
start_time = 0.0


@slash_command(name="about", description="Tr·∫°ng Th√°i Bot")
async def _about(ctx: SlashContext):
    logger.debug(f"[{ctx.guild.name}]::[{ctx.user.display_name}]: > ABOUT")
    embed = Embed(
        title="-------BOT STATUS-------",
        description="„Ö§",
        color=0x00BAFF,
    )
    button = ActionRow(
        Button(
            style=ButtonStyle.URL,
            label="github.com",
            url="https://github.com/Tinhdev061"
        )
    )

    connect_thread = pymysql.connect(host=host, user='root', password=password, database=database)
    embed.add_field(name="üè†LOCALHOST PING", value=f"{round(bot.latency * 1000)} ms„Ö§„Ö§„Ö§„Ö§„Ö§", inline=True)
    embed.add_field(name="ü§ñAPI OPEN AI", value=f'{end_time - start_time} Gi√¢y')
    embed.add_field(name="üóÉÔ∏èDATABASE PING", value=f'{connect_thread.ping()} ms')
    embed.add_field(name="‚öìCONNECT:", value=f'{connect_thread.get_host_info()}')
    embed.add_field(name="Author: ", value="qpneruy (TinhDev061)")
    await ctx.send(embeds=embed, components=button)


async def get_remaining_members(current_channel):
    members = await current_channel.fetch_members()
    total_members = len(members)
    return total_members


@listen(VoiceUserJoin)
async def __join(vs: VoiceUserJoin):
    connect_thread = pymysql.connect(host=host, user='root', password=password, database=database)
    try:
        with connect_thread.cursor() as cursor:
            select_query = f"SELECT CAST(voice_id AS SIGNED) FROM server_data WHERE ten_server = '{vs.author.guild.id}'"
            cursor.execute(select_query)
            result = cursor.fetchone()
            if result:
                if vs.channel.id == result[0]:
                    channel_d = await vs.channel.guild.create_voice_channel(f"K√™nh {vs.author.display_name}")
                    channel_id = channel_d.id
                    query = f"INSERT INTO server_{vs.author.guild.id}(active_channel) VALUES ({channel_id}) "
                    cursor.execute(query)
                    connect_thread.commit()
                    mem = vs.author
                    await mem.move(channel_d.id)
            else:
                await vs.author.send('k√™nh ch∆∞a ƒë∆∞·ª£c c√†i ƒë·∫∑t')
    finally:
        connect_thread.close()


@listen(VoiceUserLeave)
async def __leave(vs: VoiceUserLeave):
    conect_thread = pymysql.connect(host=host, user='root', password=password, database=database)
    cnx = conect_thread.cursor()
    query = f"SELECT CAST(active_channel AS SIGNED) FROM server_{vs.author.guild.id}"
    cnx.execute(query)
    res = cnx.fetchall()
    res_values = [item[0] for item in res]
    if vs.channel.id in res_values:
        await vs.channel.delete()
    query = f"DELETE FROM server_{vs.author.guild.id} WHERE active_channel = {vs.channel.id}"
    cnx.execute(query)
    conect_thread.commit()
    conect_thread.close()


host = 'localhost'
password = ''
database = 'discord_guild'


@slash_command(name="setupv", description="ƒê·∫∑t k√™nh voiceS")
@slash_option(name="channel", description="Ch·ªçn k√™nh", opt_type=OptionType.CHANNEL, required=True)
async def _setup(ctx: SlashContext, channel: interactions.OptionType.CHANNEL):
    connection = pymysql.connect(host=host, user='root', password=password, database=database)
    logger.debug(f"[{ctx.guild.name}]::[{ctx.user.display_name}]: > SETUP  \n")
    channels = channel.id
    await ctx.send(f"ƒë√£ ƒë·∫∑t k√™nh {channel.name} th√†nh k√™nh voiceS")
    try:
        with connection.cursor() as cursor:
            select_query = f"SELECT * FROM server_data WHERE ten_server = '{ctx.guild_id}'"
            cursor.execute(select_query)
            result = cursor.fetchall()
            if not result:
                print(f"Kh√¥ng t√¨m th·∫•y server c√≥ ten_server = {ctx.guild_id} trong b·∫£ng. Th√™m m·ªõi...")
                new_data = {
                    'ten_server': ctx.guild_id,
                    'voice_id': channels,
                    'gpt_channel_id': 'NULL',
                    'bard_channel_id': 'NULL',
                    'current_vol': 0.5
                }
                insert_data_query = """
                INSERT INTO server_data (ten_server, voice_id, gpt_channel_id, bard_channel_id, current_vol)
                VALUES (%(ten_server)s, %(voice_id)s, %(gpt_channel_id)s, %(bard_channel_id)s, %(current_vol)s)
                """
                cursor.execute(insert_data_query, new_data)
                connection.commit()
                print(f"ƒê√£ th√™m m·ªõi server {ctx.guild_id} v√†o b·∫£ng.")
            else:
                update_query = f"UPDATE server_data SET voice_id = '{channels}' WHERE ten_server = '{ctx.guild_id}'"
                cursor.execute(update_query)
                connection.commit()
                print(f"ƒê√£ c·∫≠p nh·∫≠t gi√° tr·ªã voice_id cho server {ctx.guild_id}.")
    finally:
        connection.close()


# Ki·ªÖm tra xem b·∫£ng c√≥ t·ªìn t·∫°i trong database kh√¥ng
def table_exists(cursor, table_name):
    cursor.execute(f"SHOW TABLES LIKE '{table_name}'")
    return cursor.fetchone() is not None


# L·∫•y t√™n t·∫•t c·∫£ c√°c b·∫£ng trong database
def get_all_tables(cursor, database_name):
    cursor.execute(f"SELECT TABLE_NAME FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_SCHEMA = '{database_name}'")
    return [table[0] for table in cursor.fetchall()]


@slash_command(name='db_refreshv2', description="L√†m m·ªõi c∆° s·ªü d·ªØ li·ªáu (x√≥a)")
async def dbv2_command(ctx: SlashContext):
    guild_ids = [str(guild.id) for guild in ctx.bot.guilds]
    conect_thread = pymysql.connect(host=host, user='root', password=password, database=database)
    cursor = conect_thread.cursor()
    current_list = get_all_tables(cursor, 'discord_guild')
    for table_name in current_list:
        if table_name.startswith('server_') and table_name[7:] not in guild_ids:
            query = f"DROP TABLE {table_name}"
            if table_name != 'server_data':
                cursor.execute(query)
    conect_thread.commit()
    conect_thread.close()
    await ctx.send('ƒê√£ l√†m m·ªõi c∆° s·ªü d·ªØ li·ªáu ph∆∞∆°ng th·ª©c x√≥a')


@slash_command(name='db_refreshv1', description="L√†m m·ªõi c∆° s·ªü d·ªØ li·ªáu (t·∫°o)")
async def dbv1_command(ctx: SlashContext):
    guilds = ctx.bot.guilds
    connection = pymysql.connect(host=host, user='root', password=password, database=database)
    create_table_query = """
        CREATE TABLE IF NOT EXISTS server_data (
            ten_server VARCHAR(255) NOT NULL,
            voice_id VARCHAR(255) NOT NULL,
            gpt_channel_id VARCHAR(255) NOT NULL,
            bard_channel_id VARCHAR(255) NOT NULL,
            current_vol DOUBLE NOT NULL
        )
    """
    cursor = connection.cursor()
    cursor.execute(create_table_query)
    for guild in guilds:
        if not table_exists(cursor, f'server_{guild.id}'):
            query = f"CREATE TABLE server_{guild.id}(active_channel VARCHAR(255) not NULL)"
            cursor.execute(query)
        select_query = f"SELECT * FROM server_data WHERE ten_server = {guild.id}"
        cursor.execute(select_query)
        result = cursor.fetchall()
        if result:
            print(f"Gi√° tr·ªã {guild.id} t·ªìn t·∫°i trong c·ªôt 'ten_server'.")
        else:
            print(f"Gi√° tr·ªã {guild.id} ƒë√£ ƒë∆∞·ª£c th√™m.")
            new_data = {
                'ten_server': guild.id,
                'voice_id': 'NULL',
                'gpt_channel_id': 'NULL',
                'bard_channel_id': 'NULL',
                'current_vol': 0.5
            }
            insert_data_query = """
            INSERT INTO server_data (ten_server, voice_id, gpt_channel_id, bard_channel_id, current_vol)
            VALUES (%(ten_server)s, %(voice_id)s, %(gpt_channel_id)s, %(bard_channel_id)s, %(current_vol)s)
            """
            cursor.execute(insert_data_query, new_data)
    connection.commit()
    connection.close()
    await ctx.send('ƒê√£ l√†m m·ªõi c∆° s·ªü d·ªØ li·ªáu ph∆∞∆°ng th·ª©c t·∫°o')


bot.load_extension("play")
bot.load_extension("gpt")
bot.load_extension("bard")
bot.start(Token)
